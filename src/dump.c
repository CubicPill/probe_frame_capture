/*
 * Use pcap_open_live() to open a packet capture device.
 * Use pcap_dump() to output the packet capture data in
 * binary format to a file for processing later.
 * Source: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.progcomc/libpcap_pcap2.htm
 */


#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pcap.h>
#include <netinet/in.h>
#include <sys/socket.h>

#define IFSZ 16
#define PCAP_SAVEFILE "./pcap_savefile"

extern char *inet_ntoa();

int usage(char *progname) {
    printf("Usage: %s <interface> [<savefile name>]\n", progname);
    exit(11);
}

int
main(int argc, char **argv) {
    pcap_t *p;               /* packet capture descriptor */
    struct pcap_stat ps;     /* packet statistics */
    pcap_dumper_t *pd;       /* pointer to the dump file */
    char ifname[IFSZ];       /* interface name (such as "en0") */
    char filename[80];       /* name of savefile for dumping packet data */
    char errbuf[PCAP_ERRBUF_SIZE];  /* buffer to hold error text */
    char prestr[80];         /* prefix string for errors from pcap_perror */
    int snaplen = 1500;        /* amount of data per packet */
    int promisc = 1;         /* do not change mode; if in promiscuous */
    /* mode, stay in it, otherwise, do not */
    int to_ms = 1000;        /* timeout, in milliseconds */
    int count = 200;          /* number of packets to capture */
    int linktype = 0;        /* data link type */
    int pcount = 0;          /* number of packets actually read */

    /*
     * For this program, the interface name must be passed to it on the
     * command line. The savefile name may be optionally passed in
     * as well. If no savefile name is passed in, "./pcap_savefile" is
     * used. If there are no arguments, the program has been invoked
     * incorrectly.
     */
    if (argc < 2)
        usage(argv[0]);

    if (strlen(argv[1]) > IFSZ) {
        fprintf(stderr, "Invalid interface name.\n");
        exit(1);
    }
    strcpy(ifname, argv[1]);

    /*
     * If there is a second argument (the name of the savefile), save it in
     * filename. Otherwise, use the default name.
     */
    if (argc >= 3)
        strcpy(filename, argv[2]);
    else
        strcpy(filename, PCAP_SAVEFILE);

    /*
     * Open the network device for packet capture. This must be called
     * before any packets can be captured on the network device.
     */
    if (!(p = pcap_open_live(ifname, snaplen, promisc, to_ms, errbuf))) {
        fprintf(stderr, "Error opening interface %s: %s\n",
                ifname, errbuf);
        exit(2);
    }


    /*
     * Open dump device for writing packet capture data. In this sample,
     * the data will be written to a savefile. The name of the file is
     * passed in as the filename string.
     */
    if ((pd = pcap_dump_open(p, filename)) == NULL) {
        /*
         * Print out error message if pcap_dump_open failed. This will
         * be the below message followed by the pcap library error text,
         * obtained by pcap_geterr().
         */
        fprintf(stderr,
                "Error opening savefile \"%s\" for writing: %s\n",
                filename, pcap_geterr(p));
        exit(7);
    }

    /*
     * Call pcap_dispatch() to read and process a maximum of count (20)
     * packets. For each captured packet (a packet that matches the filter
     * specified to pcap_compile()), pcap_dump() will be called to write
     * the packet capture data (in binary format) to the savefile specified
     * to pcap_dump_open(). Note that packet in this case may not be a
     * complete packet. The amount of data captured per packet is
     * determined by the snaplen variable which is passed to
     * pcap_open_live().
     */
    if ((pcount = pcap_dispatch(p, count, &pcap_dump, (char *) pd)) < 0) {
        /*
         * Print out appropriate text, followed by the error message
         * generated by the packet capture library.
         */
        sprintf(prestr, "Error reading packets from interface %s",
                ifname);
        pcap_perror(p, prestr);
        exit(8);
    }
    printf("Packets received and successfully passed through filter: %d.\n",
           pcount);

    /*
     * Get and print the link layer type for the packet capture device,
     * which is the network device selected for packet capture.
     */
    if (!(linktype = pcap_datalink(p))) {
        fprintf(stderr,
                "Error getting link layer type for interface %s",
                ifname);
        exit(9);
    }
    printf("The link layer type for packet capture device %s is: %d.\n",
           ifname, linktype);

    /*
     * Get the packet capture statistics associated with this packet
     * capture device. The values represent packet statistics from the time
     * pcap_open_live() was called up until this call.
     */
    if (pcap_stats(p, &ps) != 0) {
        fprintf(stderr, "Error getting Packet Capture stats: %s\n",
                pcap_geterr(p));
        exit(10);
    }

    /* Print the statistics out */
    printf("Packet Capture Statistics:\n");
    printf("%d packets received by filter\n", ps.ps_recv);
    printf("%d packets dropped by kernel\n", ps.ps_drop);

    /*
     * Close the savefile opened in pcap_dump_open().
     */
    pcap_dump_close(pd);
    /*
     * Close the packet capture device and free the memory used by the
     * packet capture descriptor.
     */
    pcap_close(p);
}
